---
title: "Supercharged Data Cleaning with R (Part One - Data Import)"
author: Timothy Deitz, Clinical Psychologist & Data Science Consultant
date: '2019-11-23'
categories:
  - Data Cleaning
tags:
  - Data Cleaning
output:
  blogdown::html_page:
    toc: no
---



<style>
body.blue { background-color:#2b3f60;}
</style>
<div id="importing-the-data" class="section level2">
<h2>Importing the Data</h2>
<p>Real-world data is messy, irritating and cumbersome. Many tutorials on data wrangling with R simply don’t prepare you for it.</p>
<p>I begin by loading all required packages.</p>
<pre class="r"><code>library(fs)
library(readr)
library(here)
library(purrr)
library(janitor)
library(dplyr)
library(stringr)
library(naniar)
library(plotly)
library(stringr)
library(forcats)</code></pre>
<p><code>fs</code> is fantastic for anything that relates to file/folder navigation using R. By using the <code>here()</code> function, and not an absolute file path, I ensure people who have the data can run my script easily</p>
<p>I next list all files in my working directory to locate the spreadsheets containing the data.</p>
<pre class="r"><code>fs::dir_ls(path = here())</code></pre>
<pre><code>## /Users/timothyjamesdeitz/Documents/tim_website/tim_website/website_files/content/post/data_import/Rplot.png
## /Users/timothyjamesdeitz/Documents/tim_website/tim_website/website_files/content/post/data_import/data_import
## /Users/timothyjamesdeitz/Documents/tim_website/tim_website/website_files/content/post/data_import/data_import.Rproj
## /Users/timothyjamesdeitz/Documents/tim_website/tim_website/website_files/content/post/data_import/early_2019.csv
## /Users/timothyjamesdeitz/Documents/tim_website/tim_website/website_files/content/post/data_import/early_2019.xlsx
## /Users/timothyjamesdeitz/Documents/tim_website/tim_website/website_files/content/post/data_import/index.Rmd
## /Users/timothyjamesdeitz/Documents/tim_website/tim_website/website_files/content/post/data_import/index.html
## /Users/timothyjamesdeitz/Documents/tim_website/tim_website/website_files/content/post/data_import/mid_2017.csv
## /Users/timothyjamesdeitz/Documents/tim_website/tim_website/website_files/content/post/data_import/mid_2017.xlsx
## /Users/timothyjamesdeitz/Documents/tim_website/tim_website/website_files/content/post/data_import/mid_2018.csv
## /Users/timothyjamesdeitz/Documents/tim_website/tim_website/website_files/content/post/data_import/mid_2018.xlsx</code></pre>
<p>I use a basic regular expression to import files that have a <code>.csv</code> extension. The contents of each spreadsheet are stored in a list of dataframes</p>
<pre class="r"><code>csv_files&lt;- fs::dir_ls(here(), regexp = &quot;\\.csv$&quot;)

pain_data_raw&lt;- csv_files %&gt;% purrr::map( ~readr::read_csv(.x)) %&gt;% 
  purrr::set_names(&quot;early_19&quot;, &quot;mid_17&quot;, &quot;mid_18&quot;)</code></pre>
<p>Check there is now a list of 3 dataframes:</p>
<pre class="r"><code>str(pain_data_raw, max.level = 0)</code></pre>
<pre><code>## List of 3</code></pre>
<p><code>readr</code> automatically guesses the data type of each imported column. But it doesn’t always guess right, which can create problems if you have large datasets. In theory, each of the three dataframes should have identical variables. But let’s check this this is true, using <code>compare_df_cols()</code> from the <code>janitor</code> package. This function lets you compare multiple dataframes in terms of variables (presence/absence and data type).</p>
<pre class="r"><code>data_comparison&lt;- janitor::compare_df_cols(pain_data_raw)

data_comparison %&gt;% dplyr::filter(column_name == &#39;EEnd_BPIPainInterference&#39;)</code></pre>
<pre><code>##                column_name early_19    mid_17  mid_18
## 1 EEnd_BPIPainInterference  numeric character numeric</code></pre>
<p>Strangely, the <code>EEnd_BPIPainInterference</code> column is specified as a numeric variable for the first and third the dataframes, but as a character varible in the second dataframe. It should definitely be numeric, and the character specification is most likely due to an error in data entry for that spreadsheet (e.g. an errant fullstop left in the column somewhere).</p>
<p>When you have many columns (&gt; 100) and data entry mistakes are likely, it is often best to manually import all columns as character variables, and then alter their type later. This can be done by adding <code>col_types = cols(.default = &quot;c&quot;)</code> to the original code.</p>
<pre class="r"><code>pain_data_raw&lt;- csv_files %&gt;% purrr::map( ~readr::read_csv(.x, col_types = cols(.default = &quot;c&quot;))) %&gt;% 
  purrr::set_names(&quot;early_19&quot;, &quot;mid_17&quot;, &quot;mid_18&quot;)</code></pre>
<p>If I now compare each dataframe again, all variables are of the character type. But there is another problem. Certain variables appear in one dataframe but not others, or appear in two dataframes but not in the third.</p>
<pre class="r"><code>head(data_comparison)</code></pre>
<pre><code>##         column_name early_19  mid_17    mid_18
## 1        Aboriginal  numeric numeric   numeric
## 2         ACCFunded  numeric numeric      &lt;NA&gt;
## 3               age  numeric numeric      &lt;NA&gt;
## 4         age_group  numeric numeric      &lt;NA&gt;
## 5 BPIAverage_change     &lt;NA&gt;    &lt;NA&gt; character
## 6  BPIAverage_group     &lt;NA&gt;    &lt;NA&gt; character</code></pre>
<p>Since I want to analyse all dataframes combined, I opt to <strong>only</strong> retain variables that are common to each dataframe. To do this, I first store the names of those common variables in a character vector.</p>
<pre class="r"><code>matching_vars&lt;- data_comparison %&gt;% dplyr::filter_at(vars(-column_name), all_vars(!is.na(.))) %&gt;% 
  dplyr::select(column_name) %&gt;% dplyr::pull(1)

#Have a look

head(matching_vars)</code></pre>
<pre><code>## [1] &quot;Aboriginal&quot;      &quot;CancerPain&quot;      &quot;CMAnaemia&quot;       &quot;CMBloodPressure&quot;
## [5] &quot;CMCancer&quot;        &quot;CMDepression&quot;</code></pre>
<p>I theniterate through each dataframe and select only these variables.</p>
<pre class="r"><code>pain_data_complete&lt;- pain_data_raw %&gt;% purrr::map(~dplyr::select(.x, matching_vars))</code></pre>
<p>To be sure it worked, I check that each dataframe now has the same number of columns.</p>
<pre class="r"><code>purrr::map_dbl(pain_data_complete, ncol)</code></pre>
<pre><code>## early_19   mid_17   mid_18 
##      273      273      273</code></pre>
<p>Success!!!</p>
<p>Having succeeded at importing and merging the data, it is a good idea to store the above steps into a reusable function.</p>
<pre class="r"><code>import_data&lt;- function() {

csv_files&lt;- fs::dir_ls(here(), regexp = &quot;\\.csv$&quot;)

pain_data_raw&lt;- csv_files %&gt;% purrr::map( ~readr::read_csv(.x, col_types = cols(.default = &quot;c&quot;))) %&gt;% 
  purrr::set_names(&quot;early_19&quot;, &quot;mid_17&quot;, &quot;mid_18&quot;)

data_comparison&lt;- janitor::compare_df_cols(pain_data_raw)

matching_vars&lt;- data_comparison %&gt;% dplyr::filter_at(vars(-column_name), all_vars(!is.na(.))) %&gt;% 
  dplyr::select(column_name) %&gt;% dplyr::pull(1)

pain_data_complete&lt;- pain_data_raw %&gt;% purrr::map(~dplyr::select(.x, matching_vars))

joined_data&lt;- dplyr::bind_rows(pain_data_complete)

}</code></pre>
<p>Test the function:</p>
<pre class="r"><code>joined_data&lt;- import_data()

str(joined_data, max.level = 0)</code></pre>
<pre><code>## Classes &#39;spec_tbl_df&#39;, &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 275 obs. of  273 variables:</code></pre>
<body class="blue">
</body>
</div>
