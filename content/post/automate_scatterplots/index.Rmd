---
title: Automate Exploratory Scatter Plots with R Plotly And Purrrr
author: Timothy Deitz, Clinical Psychologist & Aspiring Data Scientist
date: '2019-08-22'
categories:
  - R
  - plotly
  - purrr
tags:
  - plotly
  - purrr
  - functional programming
output:
  blogdown::html_page:
    toc: yes
---
<style>
body.blue { background-color:#2b3f60;}
</style>

<body class = "blue">

##Set Up

```{r setup, echo = TRUE, include=FALSE}

library(dplyr)
library(ggplot2)
library(tidyr)
library(broom)
library(purrr)
library(plotly)
library(tibble)

```

Before we start, let's tidy up the mtcars dataset by adding rownames as an explicit variable.

```{r}

mtcars$car_name<- rownames(mtcars) 

mtcars<- tibble::remove_rownames(mtcars)

```


##Simple Scatterplots

We need scatterplots to understand our data and check important statistical assumptions. Making a simple scatterplot in R is pretty straightforward. In ggplot2, the following code gives you a single scatterplot depicting the relationship between two variables (in this case, disp vs. mpg):

```{r}

ggplot(mtcars, aes(x = disp, y = mpg)) + geom_point()

```

Interactive plots often provide more detail than static ones and are especially helpful for examining individual cases:

```{r}

plot_ly(mtcars, x = ~disp, y = ~mpg) %>% add_markers()

```


Excellent! But what if you have 50, 100, or even 500 numeric variables in your dataset? Cut-and-pasting the code above 500 times doesn't sound too appealing does it? 

For this reason, there are functions like pairs() and ggpairs() that print out a panel of side-by-side scatterplots across all numeric variables. 

This works great if you only have a few variables, but otherwise plots often appear squashed or have their labels cut off. You lose important information. 

Often, I think a better option is to programatically create a list of interactive scatterplots for all numeric variables in the dataset - in one go! Using R studio, we can then scroll through the plots as we please.

Below, the function `show_all_scatterplots()` accomplishes just this.


```{r cars}

show_all_scatterplots<- function(data, point_identifier, point_size = 10) {
  
  #Select only numeric variables (we can't plot strings)
  
  numeric_data<- data %>% dplyr::select_if(is.numeric) 
  
  
  #Create a two-column dataframe with all possible pairs of numeric variable names
  
  numeric_pairs<- tibble::tibble(x_variable = names(numeric_data), 
                                 y_variable = x_variable) %>% expand.grid() 
  
  #Iterate over the two columns of numeric variable names we've created and use them 
  #to select variable from mtcars programatically
  
  purrr::map2(numeric_pairs$x_variable, numeric_pairs$y_variable, ~ { 
    
    #Create linear models for each pair of variables — required for fitting a line 
    #to each plot
    
    model<- lm(numeric_data[,.y] ~ numeric_data[,.x], data = numeric_data)
    
    #Create the plotly base for the plot. Programmatic mapping in plotly requires us 
    #to specify variables using square bracket notation, rather than the 
    #usual x = ~x, y = ~y. I don't know why.
    
    plot_ly(numeric_data, x = ~numeric_data[,.x], y = ~numeric_data[,.y],
            hoverinfo = "text", 
            text = ~paste("Identifier:", data[ , point_identifier], "<br>",
                                              .x, ": ", numeric_data[,.x], "<br>",
                                              .y, ": ", numeric_data[,.y])) %>%
      add_markers(opacity = 0.5, size = point_size, showlegend = FALSE) %>%
      
      #Add the line of best fit to each plot
      
      add_lines(y = ~fitted(model)) %>%  
      
      layout(title = paste0(.x, " vs ", .y,":", " 
                            Correlation = ", round(cor(numeric_data[,.x],
                                                       numeric_data[,.y]), 2)),
             xaxis = list(title = paste(.x)),
             yaxis = list(title = paste(.y)))
  })
  
}


```


Let's call the function:


```{r}

scatter_plot_list<- show_all_scatterplots(mtcars, point_identifier = "car_name", 
                                          point_size = 10)

```

How many plots are in the list?

```{r}

length(scatter_plot_list)

```

A lot.


Let's print one out:

```{r}


scatter_plot_list[[5]]


```

##Grouped Scatterplots

Excellent. But what if we want to look at scatterplots within subgroups? Checking within-groups scatterplots is important to avoid Simpson's Paradox — a phenomenon whereby a trend appears in several different groups of data but disappears or reverses when those groups are combined.

The new function below, `show_all_scatterplots_grouped()` takes an additional argument called *grouping_variable*. This allows it to programmatically generate a list of interactive scatterplots that depict sub-groups and sub-group trends on the same plot!


```{r}

show_all_scatterplots_grouped<- function(data, point_identifier, point_size = 10, 
                                         grouping_variable) {


  working_data<- data 

  numeric_pairs<- tibble::tibble(x_variable = names(dplyr::select_if(working_data, 
                                                                     is.numeric)),
                                     y_variable = x_variable) %>% expand.grid()

  #The only way to add a title to our grouping variable legend is via annotation. 
  #The line below sets this up.

  legend_title <- list(yref='paper',xref="paper",y=1.05,x=1.06, 
                           text= paste(grouping_variable), showarrow=F)


  purrr::map2(numeric_pairs$x_variable, numeric_pairs$y_variable, ~ {

  #Store the name of the x-axis & y-axis variables 
  #(we won't be able to acces .x or .y once we start a new map() statement)

  x_var<- .x   

  y_var<- .y

 #Make a list of dataframes, based on levels of grouping variable 
 #selected by the user

  split_df<- split(data, data[,grouping_variable])
        
  #For each dataframe in the list, add a group-specific correlation value 
  #and group size

  merged_df<- purrr::map(split_df, 
                          ~dplyr::mutate(., 
                          correlation = round(cor(.x[,x_var], .x[,y_var]), 2),
                          N = nrow(.x)
                          ))
        
  #Merge the list of dataframes back into a single dataframe
        
  merged_df<- do.call(rbind, merged_df)

  #Create a linear model to be able to plot the line of best fit
  #We specify grouped linear models using 
  #multiplication notation: y ~ x * categorical_variable

model<- lm(merged_df[,.y] ~ merged_df[,.x]*as.factor(merged_df[,grouping_variable]), 
             data = merged_df)
        
#Make the plotly base and customise the hover info

 plot_ly(merged_df, x = ~merged_df[,.x], y = ~merged_df[,.y], 
          color = ~as.factor(merged_df[ , grouping_variable]),
          hoverinfo = "text", 
          text = ~paste("Identifier:", merged_df[ , point_identifier], "<br>",
                     .x, ": ", merged_df[,.x], "<br>",
                     .y, ": ", merged_df[,.y], "<br>",
                      "Group Correlation:", merged_df$correlation, "<br>",
                      "Group N:", merged_df$N
                                                  
                )) %>%

    add_markers(opacity = 0.5, size = point_size, showlegend = TRUE) %>%

    add_lines(y = ~fitted(model), showlegend = FALSE) %>%

    #Add our title to the legend

    layout(title = paste0(.x, " vs ", .y,":", " Correlation = ", 
                  round(cor(merged_df[,.x], merged_df[,.y]), 2)),
           xaxis = list(title = paste(.x)),
           yaxis = list(title = paste(.y)), annotations = legend_title)




      })

    }



```


Call `show_all_scatterplots_grouped()`:

```{r, include=FALSE}

grouped_scatterplot_list<- show_all_scatterplots_grouped(mtcars, point_identifier = "car_name", 
                                                         point_size = 10, grouping_variable = "cyl")

```


Print one plot from the list of plots returned:

```{r}

grouped_scatterplot_list[[23]]


```

Print another one:

```{r}

grouped_scatterplot_list[[55]]


```

The plot above is an example of Simpson's Paradox! Note how there is almost no relationship between carb and drat when considering all cases as one group, but positive correlations between these variables when we consider subgroups! (with the caveat of small sample sizes)

That's it for now. I could find very little info online about automating exploratory plots using plotly and purrr, and hope this post helps speed up your data exploration. Of course, feel free to get in touch if you have any questions.

</body>
