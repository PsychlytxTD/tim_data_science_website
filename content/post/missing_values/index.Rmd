---
title: Towards A Workflow For Exploring Missing Values
author: Timothy Deitz, Clinical Psychologist & Aspiring Data Scientist
date: '2019-09-18'
categories:
  - R
  - plotly
  - ggplot2
  - naniar
tags:
  - plotly
  - ggplot2
  - naniar
output:
  blogdown::html_page:
    toc: yes
---
<style>
body.blue { background-color:#2b3f60;}
</style>

<body class = "blue">


```{r setup, echo = TRUE, include=FALSE}

library(dplyr)
library(ggplot2)
library(tidyr)
library(broom)
library(forcats)
library(purrr)
library(plotly)
library(tibble)
library(naniar)
library(visdat)
library(DT)

```


##Setting Up

Missing values are often inevitable, and typically a source of anxiety among people responsible for analysing data. This post aims to sketch out the beginnings of a workflow for missing value exploration and identification. Thanks to [Nicholas Tierney ](https://github.com/njtierney) for the excellent `naniar` and `visdat` packages from which I draw inspiration.

Let's begin by simulating some psychological data. I've deliberately made a small dataframe so that the steps are easier to understand.

Each character string in the `scale` column represents a psychological outcome measure. The PHQ9 is used to assess depression, and the GAD7 assesses anxiety. The data represent scores across these two measures for different individuals at various points in time.

```{r}

data<- tibble::tribble(
  
  ~scale, ~date,        ~ score, ~pts,   ~id,                    ~sex,
  "PHQ9", "02/02/2003",   10,      9,     "",                     "m",  
  "GAD7","02/03/2003",   12,      11,    uuid::UUIDgenerate(),   "f",
  "PHQ9", "01/01/2004",  8,       9,     uuid::UUIDgenerate(),   999,
  "GAD7", "04/02/2005",  8,       ".",   uuid::UUIDgenerate(),   "m",
  "GAD7", "04/02/2005",  3,       4,     uuid::UUIDgenerate(),   "f", 
  "PHQ9", "04/02/2005",  4,       2,     "",                     -98,   
  "GAD7", "09/02/2006",  1,       ".",   uuid::UUIDgenerate(),   "m",
  "PHQ9", "02/02/2003",  1,       1,     uuid::UUIDgenerate(),   -999,
  "GAD7","02/03/2003",   9,       8,     uuid::UUIDgenerate(),   "f",
  "PHQ9", "N/A",         7,       8,     uuid::UUIDgenerate(),   999,
  "GAD7", "04/02/2005",  4,       7,     uuid::UUIDgenerate(),   "f",
  "GAD7", "04/02/2005",  2,       4,     "",                     "m",
  "PHQ9", "N/A",         8,       7,     uuid::UUIDgenerate(),   -98,
  "GAD7", "N/A",         8,       7,     uuid::UUIDgenerate(),   "f"
  
)

```

Here's what the data look like

```{r echo = FALSE}

data

```

As you can tell, a diverse and inconsistent set of values have been used to denote missing data.

Before doing much else, it is often a good idea to take a look at the uniqe range of values within each variable â€” this lets us identify odd values that may either be mistakes or missing value codes.


```{r echo = TRUE}

purrr::map(data, unique)

```

It is easy to see that missing values have been coded with -999, -98, ., "N/A" and "".

If reading the data from a csv, missing value codes can be specified at the time of import.

For example, assuming our file is called `outcomes.csv`:


```{r echo = TRUE, eval = FALSE}

data<- readr::read_csv("outcomes.csv", 
       na = c("N/A", ".", "", "-999", "-98"))

```

Of course, the `readr` package will try to guess column types automatically when importing.

Sometimes however, it isn't possible to specify a range of missing value codes when importing.

This is where `naniar` package becomes really useful. Using this package, we can replace any predetermined missing value codes (e.g. -999) with explicit NA values.

```{r echo = TRUE}

na_vals<- c("N/A", ".", "", "-999", "-98")

data_na<- data %>% naniar::replace_with_na_all(condition = ~.x %in% na_vals)

data_na

```

As you can see, missing values are now explicit and no longer represented by heterogeneous digits/letters. 

Of course, we may only only want to target a selection of variables, under certain conditions. This can be done as follows:

```{r echo = TRUE, eval = FALSE}

#Only code missing values for `sex` and `id`

data_na<- data%>% naniar::replace_with_na_at(.vars = c("sex", "id"), 
                   condition = ~.x %in% na_vals)

```

and

```{r echo = TRUE, eval = FALSE}

#Only apply missing value coding to character variables

data_na<- data %>% naniar::replace_with_na_if(.predicate = is.character, 
                   condition = ~.x %in% na_vals)

```

##Missing Values at Level of the Dataframe

I think it can be helpful to approach missing values on on three levels: (1) At the level of the whole dataframe, (2) at the level of individual rows (i.e. cases), and (3) at the level of variables.

Let's start with the whole dataframe. We can quickly find out how many missing values and complete values exist, as follows:

```{r echo = TRUE}

#Count missing values
naniar::n_miss(data_na)

#Count complete values 
naniar::n_complete(data_na)

```

And to calculate the percentage of missing values in the dataframe:

```{r echo = TRUE}

#Get proportion/percentage of missing values
naniar::n_miss(data_na) / naniar::n_complete(data_na)

```

So 15% of values in this dataframe are missing.

##Row-Wise Missing Value Exploration

Now we valuate missingness at the level of individual rows. 

First, what percentage of rows have missing data?

```{r echo = TRUE}

naniar::pct_miss_case(data_na)

```

Great, 64% of our rows contain missing data.

Now let's get a row-by-row summary of missing data characteristics within each row:

```{r echo = TRUE}

#Save to object because we'll use this output again in a moment

case_missing_summary<- naniar::miss_case_summary(data_na)

case_missing_summary

```

This output tells us that case 6 has two values missing, constituting 33% missing values within his/her row.

But I think it is actually easier to visualise this information graphically, so let's do that (don't forget to hover over the plot):

```{r echo = TRUE}

#Find the case numbers of those cases that have missing values
missing_cases<- case_missing_summary$case[which(case_missing_summary$n_miss != 0)]

#Subset the data to only pull out rows with missing values
all_missing<- data_na[missing_cases,]

#Summarise these cases & add identifier

all_missing_summary<-  all_missing %>% naniar::miss_case_summary() %>% mutate(identifier = all_missing$id)

#Plot the missingness by row

missing_by_row_plot<- ggplot(all_missing_summary, 
                             aes(x = fct_reorder(identifier, pct_miss), y = pct_miss)) + 
  geom_bar(stat = "identity") + coord_flip() + xlab("Case") + ylab("Percentage Missing") +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1L, scale = 1)) 

missing_by_row_plot<- missing_by_row_plot + aes(text = paste("N Missing: ", n_miss, "<br>",
                                                             "% Missing: ", round(pct_miss, 2), "<br>",
                                                             "Case Number:", case))

ggplotly(missing_by_row_plot, tooltip = "text")

```

Another good way to evaluate row-wise missingness is using a raster or tile plot. The function below, from the `visdat` package, is great for this. 

```{r}

vis_dat_plot<- visdat::vis_dat(data_na)

ggplotly(vis_dat_plot)

```

Here we can see, for example, that case (row) 6 has missing values for`id`a nd `sex` but complete values for all the other variables.

##Variable-Wise Missing Data Exploration

After exploring row-wise missingness, it is time to identify missing values on a variable by basis. First, we can work out the percentage of our variables that have missing data.

```{r echo = TRUE}

naniar::prop_miss_var(data_na)

```

So we see that 60% of our variables contain at least one missing value.

Next, we want a break-down of how many values (and what percentage) are missing specifically on each variable:

```{r echo = TRUE}

missing_by_var<- naniar::miss_var_summary(data_na)

missing_by_var

```

Again, it helps to visualise this information with a plot (and don't forget to hover over the plot to get the extra
info we added when customising the tooltip).

```{r echo = TRUE}

missing_by_var_plot<- ggplot(missing_by_var, 
                             aes(x = fct_reorder(variable, pct_miss), 
                                 y = pct_miss)) + 
  geom_bar(stat = "identity") + coord_flip() + xlab("Variable") + 
  ylab("Percentage Missing") +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1L, scale = 1)) 

  missing_by_var_plot<- missing_by_var_plot + 
    aes(text = paste("N Missing: ", n_miss, "<br>",
                     "% Missing: ", round(pct_miss, 2)))
  
  ggplotly(missing_by_var_plot, tooltip = "text")
  
```

It is also easy to break down missing value across variables **within levels** of a grouping variable as follows:

```{r echo = TRUE}

data_na %>% group_by(scale) %>% naniar::miss_var_summary()

```

I hope this this post was helpful as an intro to missing values exploration and any feedback is of course welcome.

</body>
